# Разработка клиент-серверных приложений: взаимодействие React.js фронтенда с Django/FastAPI/Spring бэкендом

## ОГЛАВЛЕНИЕ

-
[ВВЕДЕНИЕ](#введение)
[1. Архитектура Apache](#1-архитектура-apache)
[2.	Архитектура Nginx](#2.-Архитектура-Nginx)
[3.	Сравнительный анализ производительности](#3.-Сравнительный-анализ-производительности)
[4.	Сценарии использования](#4.-Сценарии-использования)
[5.	Примеры конфигурации](#5.-Примеры-конфигурации)
[ЗАКЛЮЧЕНИЕ](#заключение)
[СПИСОК ЛИТЕРАТУРЫ](#список-литературы)

---

## ВВЕДЕНИЕ

Веб-серверы Apache HTTP Server и Nginx – два самых распространенных решения с открытым исходным кодом, обеспечивающих работу миллионов сайтов. В сумме они обслуживают более половины трафика в интернете. Оба могут обрабатывать статический и динамический контент, однако кардинально различаются по архитектуре и модели обработки запросов. По данным W3Techs (декабрь 2025), Nginx используется на 33,1 % сайтов, Apache – на 24,5 % . В последние годы доля Nginx стабильно растет – в частности, он часто выбирается для высоконагруженных проектов, тогда как Apache остаётся востребованным в «наследственных» проектах и на shared-хостингах благодаря гибкой модульной архитектуре. Цель данного отчёта – системно рассмотреть архитектуру обоих серверов, сравнить их производительность и привести примеры конфигурации, чтобы понять, в каких сценариях предпочтительнее тот или иной сервер.
 
--

## 1. Архитектура Apache
Apache HTTP Server (HTTPd) впервые выпущен в 1995 году и быстро стал отраслевым стандартом. Его ключевым преимуществом является модульность и гибкость: функционал сервера (поддержка языков, аутентификация, SSL, проксирование и т.д.) реализуется через динамические модули (DSO), которые можно подключать или отключать по мере необходимости. Конфигурация Apache может вестись централизованно, а при необходимости изменять поведение сервера на уровне отдельных директорий используются файлы .htaccess Это позволяет, например, делегировать разработчикам право менять правила перенаправления или доступ к ресурсам без перезагрузки всего сервера, но увеличивает нагрузку на файловую систему и отрицательно сказывается на производительности (Apache при обработке каждого запроса обязан проверять наличие .htaccess в каждом каталоге пути)
Модель обработки соединений в Apache основана на MPM (Multi-Processing Module). На практике чаще всего используются два варианта: prefork (каждое соединение обрабатывается отдельным процессом) и worker (несколько потоков внутри процесса) При модуле prefork создаётся один процесс на соединение, что упрощает взаимодействие с не потокобезопасными модулями (например, mod_php), но сильно ограничивает масштабируемость из-за больших накладных расходов на создание процессов Модуль worker позволяет одному процессу управлять несколькими потоками, что улучшает масштабируемость, однако усложняет работу с некоторыми модулями. Начиная с Apache 2.4, добавлен модуль event, оптимизированный для работы с keep-alive соединениями: он выделяет отдельные потоки для «спящих» соединений и отдельные для активных запросов, что повышает общую производительность при большом количестве одновременных подключений
Таким образом, в классической схеме Apache для каждого запроса создаётся отдельный процесс или поток Это обеспечивает простоту реализации и высокую гибкость, но при росте числа соединений требует всё больше ресурсов (главным образом – памяти). Как отмечено в обзоре, при высокой нагрузке Apache «потребляет много памяти и плохо масштабируется с ростом количества одновременных соединений» В то же время из коробки Apache может выполнять динамический код (PHP, Perl, Python и т.д.) непосредственно в своих процессах посредством соответствующих модулей (mod_php, mod_perl и др.) Это уменьшает задержки обработки при динамическом контенте и упрощает конфигурацию (нет необходимости настраивать внешний FastCGI). Дополнительные модули, такие как mod_rewrite (для перенаправлений) или mod_ssl (SSL), интегрируются на уровне конфигурации сервера, что даёт администраторам широкие возможности, но увеличивает поверхность атаки при использовании ненужных модулей.

---

## 2.	Архитектура Nginx
Nginx (произносится «engine x») появился в 2004 году. Его создатель, Игорь Сысоев, изначально разрабатывал сервер для решения проблемы C10k (обработка тысяч одновременных соединений). В отличие от Apache, Nginx использует асинхронную, событийно-ориентированную архитектуру. Существует один главный (master) процесс, который загружает конфигурацию и управляет несколькими рабочими (worker) процессами. Каждый воркер работает в «событийном цикле» (event loop) и способен обслуживать тысячи соединений в неблокирующем режиме. При таком подходе не требуется создание отдельного потока или процесса на каждый запрос – один воркер обрабатывает события и переключается между клиентами по мере их готовности. Это обеспечивает высокую масштабируемость: Nginx «эффективно обрабатывает тысячи одновременных запросов статики» при минимальном потреблении ресурсов. По сути, каждый рабочий процесс использует механизм epoll/kqueue (в зависимости от ОС) для эффективного распределения работы, что позволяет обслуживать десятки тысяч соединений на одном сервере при умеренной нагрузке на CPU и RAM.
Конфигурация Nginx централизована: все настройки задаются в основном файле nginx.conf (и включаемых в него файлах). В случае изменений требуется перезагрузка или обновление конфигурации (через сигналы), после чего мастер-процесс запускает новые воркеры, а старые корректно завершают обслуживание текущих запросов. Механизм .htaccess в Nginx отсутствует – такая децентрализованная настройка не предусмотрена. Это повышает предсказуемость и производительность (Nginx читает конфиг один раз при запуске, тогда как Apache проверяет .htaccess при каждом запросе).
Поддержка модулей в Nginx изначально была менее гибкой, чем у Apache: многие модули требовали перекомпиляции ядра. В современных версиях Nginx введена динамическая загрузка модулей, однако набор доступных модулей (особенно для специфических языков и фреймворков) всё ещё меньше, чем у Apache. Коммерческая версия Nginx Plus предоставляет дополнительные модули и возможности. Благодаря своей архитектуре Nginx часто используется как reverse proxy или балансировщик нагрузки – он эффективно отдаёт статический контент и пересылает динамические запросы на бэкенд-приложения (PHP-FPM, uWSGI, Gunicorn и т.д.).

---

## 3.	Сравнительный анализ производительности
Архитектурные различия обуславливают и особенности производительности. В области статического контента Nginx «безоговорочно лидирует» по скорости отдачи и масштабируемости. При тестах Nginx способен обрабатывать тысячи запросов на статические файлы в секунду, сохраняя низкое потребление памяти и CPU. Например, при нагрузке 100 одновременных соединений Nginx выдал около 3200 запросов/с (среднее время ответа ~28 мс), тогда как Apache с MPM prefork – примерно 1100 запросов/с (время ~85 мс). Для Apache с worker MPM эти показатели немного выше (~1600 req/s, 58 мс), но всё же уступают Nginx. В тестах ItTelo приведены более общие ориентировочные цифры: у Apache пропускная способность отдачи статики около 800–1200 req/s, у Nginx – 2500–3500 req/s (с учётом разной конфигурации). Это объясняется тем, что Apache при высокой статической нагрузке тратит значительные ресурсы на создание и переключение процессов/потоков, тогда как Nginx отрабатывает большую часть запросов внутри одного цикла событий.
При динамическом контенте (PHP, приложения на Python/Ruby и т.п.) разница в производительности менее заметна и зависит от настройки бэкенда. Apache может выполнять скрипты напрямую с помощью встроенных модулей (mod_php, mod_perl и др.), что уменьшает задержку при небольших нагрузках. Nginx сам код не интерпретирует и проксирует запросы к внешнему FastCGI/WSGI серверу. Это добавляет небольшой оверхед на межпроцессное взаимодействие, но даёт лучшие гарантию устойчивости: падение бэкенда не «потянет за собой» весь Nginx. В тестах ItTelo при проверке динамического PHP-приложения (на примере WordPress) Nginx+PHP-FPM показал ≈180 req/s, Apache+mod_php ≈165 req/s. При этом связка Nginx (фронтенд) + Apache (бекенд) продемонстрировала ≈210 req/s благодаря тому, что Nginx обработал статику и кешировал ответы. Таким образом, при хорошем тюнинге и используемых кешах Nginx способен достичь производительности Apache в работе с динамикой, сохраняя при этом свои преимущества по отдаче статики.
Что касается использования ресурсов и параллелизма, Nginx выигрывает однозначно. При большом числе одновременных соединений Nginx тратит значительно меньше памяти – порядка 50–70 МБ на 1000 соединений против ≈150–200 МБ у Apache (с prefork без оптимизаций). Каждый воркер Nginx может обслуживать тысячи клиентов, тогда как у Apache под каждое соединение резервируется отдельный поток/процесс с заметным расходом RAM. По данным ItTelo, Nginx способен выдерживать десятки тысяч соединений без существенной деградации, тогда как Apache требует кропотливой настройки MPM и существенно более мощных ресурсов для приближения к такому уровню параллелизма. Иными словами, в сценариях, где критична высокая нагрузка и много «медленных» клиентов, Nginx показывает заметно лучшие результаты.
Таблица 1 ниже обобщает ключевые отличия в архитектуре и производительности Apache и Nginx. В ней приведены год релиза, модель обработки запросов, особенности работы со статикой/динамикой, а также требования к ресурсам и конфигурационным возможностям.

## 4.	Сценарии использования
Практический выбор между Apache и Nginx определяется характером нагрузки и требованиями проекта. Наиболее типичные рекомендации сводятся к следующему:
1) Apache: предпочтителен для проектов с интенсивной обработкой динамики и необходимостью гибкой настройки на уровне директорий. Например, PHP-приложения на shared-хостинге, где важна поддержка файлов .htaccess и модулей вроде mod_rewrite для сложных правил, или наследуемые системы с требованием «сохранить всё как есть». Если нужно задействовать редко используемые или legacy-модули (аутентификация LDAP, mod_security, специфичные фильтры содержимого), то Apache с его гигантской экосистемой модулей обеспечивает максимальную совместимость.
2) Nginx: лучше подходит для сайтов с высокой нагрузкой и большим числом одновременных соединений. Если проект представляет собой преимущественно статический контент (медиа-контент, CDN) или микросервисную архитектуру, где важна экономия ресурсов, то Nginx обеспечивает более эффективную отдачу и масштабируемость. Также Nginx часто выбирают для задач обратного прокси/балансировщика нагрузки (например, перед бэкендом из Apache или приложением на Node.js) благодаря его способности быстро распределять трафик и обрабатывать TLS (SSL-терминацию) с меньшей нагрузкой на систему.
3) Связка Nginx + Apache: на практике распространена гибридная схема «Nginx спереди, Apache сзади». В такой конфигурации Nginx работает как фронтенд: слушает порты 80/443, отдаёт статику и SSL, а динамические запросы проксирует на Apache (обычно работающий на другом порту, например 8080). Преимущества очевидны: Nginx эффективно управляет тысячами соединений и разгружает Apache от простых задач, а Apache обрабатывает PHP и сложную логику. Наглядный пример конфигурации (фрагмент nginx.conf) для такого случая приведён в разделе 6.
Таким образом, окончательный выбор веб-сервера часто зависит от конкретной архитектуры проекта. Во многих ситуациях целесообразно объединять сильные стороны обоих серверов – отдавать статические ресурсы и балансировать нагрузку через Nginx, а динамические запросы обрабатывать модульно в Apache.

## 5.	Примеры конфигурации
Ниже приведены упрощённые примеры конфигураций Apache и Nginx для виртуального хоста example.com. Они иллюстрируют основные директивы, используемые в каждом сервере.
•	Apache (VirtualHost): простой конфиг для сайта на порту 80 с документ-рутом и базовыми правами доступа:

 <VirtualHost *:80>
    ServerName example.com
    DocumentRoot /var/www/example.com
    <Directory /var/www/example.com>
        AllowOverride All
        Require all granted
    </Directory>
</VirtualHost>

Этот блок настраивает виртуальный хост, задаёт корневую директорию сайта (DocumentRoot) и разрешает доступ к ней (с отключёнными .htaccess для повышения производительности). По аналогии можно добавить ServerAlias для дополнительных имён хоста и задать отдельные логи через директивы ErrorLog и CustomLog.
•	Nginx (server block): конфигурация сервера для того же домена на 80 порту.
 
 server {
    listen       80;
    server_name  example.com;
    root         /var/www/example.com;
    index        index.html index.php;
    location / {
        try_files $uri $uri/ =404;
    }
    location ~ \.php$ {
        fastcgi_pass unix:/run/php/php-fpm.sock;
        include fastcgi_params;
        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
    }
}

В этом server-блоке задаётся server_name, корневая папка и индексные файлы. Первый location отдаёт статические ресурсы напрямую (или возвращает 404, если файл не найден). Второй обрабатывает PHP: он перенаправляет запросы к сокету PHP-FPM (FastCGI) и передаёт скрипты на выполнение. При необходимости можно добавлять другие location (например, для кеширования статики или перенаправлений). Такой конфиг демонстрирует типовой подход: Nginx сам отдаёт статику и выполняет роль прокси для динамики.
•	Пример связки (Nginx → Apache): при использовании схемы «Nginx спереди, Apache сзади» Nginx конфиг может выглядеть так (отдаёт статику и проксирует всё остальное):
 
 server {
    listen 80;
    server_name example.com;
    root /var/www/example.com;
    # Отдача статических файлов по умолчанию

    location / {
        # Все запросы проксируются на Apache
        proxy_pass http://127.0.0.1:8080;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
    }
}

Здесь Nginx кеширует статику на 30 дней, а динамические запросы (например, к PHP через модуль mod_php или CGI на Apache) перенаправляет на Apache, запущенный на порту 8080. Такая конфигурация широко применяется для ускорения сайтов на WordPress, интернет-магазинов и др., сочетая производительность Nginx с гибкостью Apache.

 
## ЗАКЛЮЧЕНИЕ
Сравнивая веб-серверы Apache и Nginx, можно отметить следующий вывод: Nginx выигрывает по эффективности и масштабируемости благодаря событийно-ориентированной архитектуре. Он превосходно отдаёт статический контент и выдерживает десятки тысяч одновременных соединений при низком потреблении ресурсов. Apache же обладает богатой экосистемой модулей и гибкими механизмами конфигурации (.htaccess, различные MPM), что даёт преимущество в сложных динамических сценариях и там, где нужны специфические функции (модульная безопасность, расширенные правила перенаправления и т.д.) .
В реальной практике часто разумно использовать их совместно: отдавать через Nginx статику и балансировать нагрузку, а запускать динамические приложения на Apache или других бэкендах. Приведённый анализ и тесты подтверждают тенденцию: для проектов с высокими требованиями по производительности и пропускной способности обычно предпочтительнее Nginx (особенно в роли обратного прокси или балансировщика), тогда как для проектов с обширной историей и потребностью в тонкой настройке больше подходит Apache. Важно отметить, что конкретный выбор всегда зависит от целей и ограничений проекта. Обе технологии активно развиваются и обновляются; регулярное тестирование на реальных сценариях и корректная настройка остаются ключом к оптимальному использованию любого веб-сервера.
 
## СПИСОК ЛИТЕРАТУРЫ
1.	Латыпов Э. Ф. Сравнительный анализ работы веб-серверов Apache и Nginx // Компьютерные и информационные науки. — 2017. — № 3. — С. 45–52.
2.	Ellingwood J. Apache vs Nginx: Practical Guide [Электронный ресурс]. — DigitalOcean, 2015. — URL: https://www.digitalocean.com/community/tutorials/apache-vs-nginx-practical-considerations (дата обращения: 26.12.2025).
3.	RuWeb. Веб-серверы Apache vs Nginx [Электронный ресурс]. — RuWeb.net, 2025. — URL: https://ruweb.net/apache-vs-nginx (дата обращения: 26.12.2025).
4.	ItTelo. Apache веб-сервер против Nginx: что выбрать для вашего проекта [Электронный ресурс]. — ItTelo, 2025. — URL: https://ittelo.ru/apache-vs-nginx (дата обращения: 26.12.2025).
5.	NGINX. Руководство для начинающих (NGINX Beginner’s Guide) [Электронный ресурс]. — NGINX.org. — URL: https://nginx.org/ru/docs/beginners_guide.html (дата обращения: 26.12.2025).
6.	W3Techs. Usage statistics of web servers [Электронный ресурс]. — W3Techs.com. — URL: https://w3techs.com/technologies/overview/web_server (дата обращения: 26.12.2025).



Реферат размещен по ссылке:
      https://github.com/AIS-436/Huzin_Denis_Fanisovich_6

